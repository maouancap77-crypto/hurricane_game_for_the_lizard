<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Furac√£o: Sobreviv√™ncia no Texas do Calango</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(to bottom, #87CEEB 0%, #98FB98 100%);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            user-select: none;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #gameCanvas {
            display: block;
            background: linear-gradient(45deg, #87CEEB 0%, #90EE90 50%, #F0E68C 100%);
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 10;
        }

        #energy-bar {
            width: 200px;
            height: 20px;
            background: rgba(0,0,0,0.3);
            border: 2px solid white;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 10px;
        }

        #energy-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff4444, #ffaa44, #44ff44);
            transition: width 0.3s ease;
        }

        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            font-size: 14px;
            z-index: 10;
        }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            display: none;
            z-index: 20;
        }

        .restart-btn {
            background: #5D5CDE;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 15px;
            font-size: 16px;
        }

        .restart-btn:hover {
            background: #4a49c7;
        }

        @media (max-width: 768px) {
            #ui {
                font-size: 14px;
            }
            
            #instructions {
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <div id="ui">
            <div>Energia: <span id="energy-text">100</span>%</div>
            <div id="energy-bar">
                <div id="energy-fill" style="width: 100%"></div>
            </div>
            <div>Velocidade: <span id="speed-text">0</span> km/h</div>
            <div>Pontua√ß√£o: <span id="score-text">0</span></div>
            <div>Tempo: <span id="time-text">0</span>s</div>
        </div>

        <div id="instructions">
            <div><strong>Controles:</strong></div>
            <div>WASD ou Setas - Movimento</div>
            <div>Espa√ßo - Dash (absorve furac√µes pequenos e pode canibalizar)</div>
            <div><strong>Mec√¢nicas:</strong></div>
            <div>üå™Ô∏è Amarelo = Furac√£o pequeno (pode engolir com dash, pode ser canibalizado)</div>
            <div>üå™Ô∏è Laranja = Furac√£o crescido (n√£o pode engolir, mas pode canibalizar)</div>
            <div>üü¢ Zonas verdes = Recarregam energia e fazem furac√µes nascerem</div>
            <div>üî¥ Furac√µes vermelhos = Ficam mais inteligentes, fogem se voc√™ for maior!</div>
        </div>

        <div id="game-over">
            <h2>Fim de Jogo!</h2>
            <p>Seu furac√£o se dissipou...</p>
            <p>Tempo sobrevivido: <span id="final-time">0</span>s</p>
            <button class="restart-btn" onclick="restartGame()">Jogar Novamente</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Configurar canvas responsivo
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Timers para spawns
        let smallHurricaneSpawnTimer = 0;
        let houseSpawnTimer = 0;

        // Estado do jogo
        let gameState = {
            player: {
                x: 1000,
                y: 1000,
                vx: 0,
                vy: 0,
                rotation: 0,
                size: 25,
                maxSize: 150,
                energy: 100,
                particles: []
            },
            camera: {
                x: 0,
                y: 0
            },
            enemies: [],
            smallHurricanes: [],
            windZones: [],
            buildings: [],
            inhabitants: [],
            cities: [],
            keys: {},
            gameTime: 0,
            gameRunning: true,
            score: 0,
            mapSize: 2500
        };

        // Classe para part√≠culas do furac√£o
        class Particle {
            constructor(x, y, distance, speed, color) {
                this.angle = Math.random() * Math.PI * 2;
                this.distance = distance;
                this.speed = speed;
                this.x = x;
                this.y = y;
                this.color = color;
                this.life = 1;
            }

            update(centerX, centerY, rotation) {
                this.angle += this.speed + rotation * 0.1;
                this.x = centerX + Math.cos(this.angle) * this.distance;
                this.y = centerY + Math.sin(this.angle) * this.distance;
                this.life -= 0.02;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        // Classe para furac√µes inimigos
        class Enemy {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.size = 40 + Math.random() * 30;
                this.maxSize = 200;
                this.rotation = 0;
                this.particles = [];
                this.targetPlayer = false;
                this.huntingBuildings = false;
                this.target = null;
                this.escaping = false;

                for (let i = 0; i < 20; i++) {
                    this.particles.push(new Particle(x, y, Math.random() * this.size, 
                                                   0.1 + Math.random() * 0.1, '#ff4444'));
                }
            }

            update() {
                // IA aprimorada
                const playerDistance = Math.sqrt((this.x - gameState.player.x) ** 2 + (this.y - gameState.player.y) ** 2);
                if (gameState.player.size > this.size * 1.1) {
                    // Foge do player e busca crescer
                    this.escaping = true;
                    this.targetPlayer = false;
                    this.huntingBuildings = false;

                    // Foge do player
                    const dx = this.x - gameState.player.x;
                    const dy = this.y - gameState.player.y;
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    if (distance < 350) {
                        this.vx += (dx / distance) * 0.8;
                        this.vy += (dy / distance) * 0.8;
                    }

                    // Busca zona de vento para crescer
                    let nearestZone = null, nearestZoneDist = Infinity;
                    gameState.windZones.forEach(zone => {
                        const dzx = zone.x - this.x, dzy = zone.y - this.y;
                        const dzdist = Math.sqrt(dzx*dzx + dzy*dzy);
                        if (dzdist < nearestZoneDist) {
                            nearestZone = zone;
                            nearestZoneDist = dzdist;
                        }
                    });
                    if (nearestZone) {
                        this.vx += (nearestZone.x - this.x) / nearestZoneDist * 0.5;
                        this.vy += (nearestZone.y - this.y) / nearestZoneDist * 0.5;
                    }
                } else {
                    // Se for maior ou pr√≥ximo do player, ca√ßa o player
                    this.escaping = false;
                    if (playerDistance < 200) {
                        this.targetPlayer = true;
                        this.huntingBuildings = false;
                    } else if (Math.random() < 0.6) {
                        this.huntingBuildings = true;
                        this.targetPlayer = false;
                        let nearestBuilding = null;
                        let nearestDistance = Infinity;
                        gameState.buildings.forEach(building => {
                            if (!building.destroyed) {
                                const dist = Math.sqrt((this.x - building.x) ** 2 + (this.y - building.y) ** 2);
                                if (dist < nearestDistance) {
                                    nearestDistance = dist;
                                    nearestBuilding = building;
                                }
                            }
                        });
                        this.target = nearestBuilding;
                    } else {
                        this.targetPlayer = true;
                        this.huntingBuildings = false;
                    }
                }

                // Comportamento
                if (this.targetPlayer && !this.escaping) {
                    const dx = gameState.player.x - this.x;
                    const dy = gameState.player.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance > 50) {
                        this.vx += (dx / distance) * 0.4;
                        this.vy += (dy / distance) * 0.4;
                    }
                } else if (this.huntingBuildings && this.target && !this.target.destroyed) {
                    const dx = this.target.x - this.x;
                    const dy = this.target.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance > 30) {
                        this.vx += (dx / distance) * 0.3;
                        this.vy += (dy / distance) * 0.3;
                    }
                }

                // Movimento aleat√≥rio menor
                this.vx += (Math.random() - 0.5) * 0.3;
                this.vy += (Math.random() - 0.5) * 0.3;

                // Aplicar atrito
                this.vx *= 0.98;
                this.vy *= 0.98;

                // Limitar velocidade baseada no tamanho
                const maxSpeed = Math.max(1.5, 3 - (this.size / 50));
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                if (speed > maxSpeed) {
                    this.vx = (this.vx / speed) * maxSpeed;
                    this.vy = (this.vy / speed) * maxSpeed;
                }

                this.x += this.vx;
                this.y += this.vy;

                // Manter dentro dos limites do mapa
                this.x = Math.max(this.size, Math.min(gameState.mapSize - this.size, this.x));
                this.y = Math.max(this.size, Math.min(gameState.mapSize - this.size, this.y));

                // Destruir pr√©dios e crescer
                gameState.buildings.forEach(building => {
                    if (!building.destroyed && this.isCollidingWithBuilding(building)) {
                        const damage = speed * 3;
                        const points = building.takeDamage(damage);
                        if (points > 0) {
                            this.size = Math.min(this.maxSize, this.size + 2);
                            if (this.particles.length < this.size * 0.8) {
                                for (let i = 0; i < 2; i++) {
                                    this.particles.push(new Particle(this.x, this.y, Math.random() * this.size, 
                                                                   0.1 + Math.random() * 0.1, '#ff4444'));
                                }
                            }
                        }
                    }
                });

                // Crescimento acelerado em zonas de vento
                gameState.windZones.forEach(zone => {
                    const dx = this.x - zone.x;
                    const dy = this.y - zone.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < zone.size) {
                        this.size = Math.min(this.maxSize, this.size + 0.18); // antes era 0.05
                    }
                });

                this.rotation += 0.1;

                // Atualizar part√≠culas
                this.particles.forEach(particle => {
                    particle.update(this.x, this.y, this.rotation);
                    if (particle.life <= 0) {
                        particle.life = 1;
                        particle.distance = Math.random() * this.size;
                        particle.angle = Math.random() * Math.PI * 2;
                    }
                });
            }

            isCollidingWithBuilding(building) {
                return this.x < building.x + building.width &&
                       this.x + this.size > building.x &&
                       this.y < building.y + building.height &&
                       this.y + this.size > building.y;
            }

            draw() {
                ctx.fillStyle = '#ff2222';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * 0.3, 0, Math.PI * 2);
                ctx.fill();

                this.particles.forEach(particle => particle.draw());
            }

            canPlayerAbsorb(player) {
                return player.size > this.size * 1.2;
            }
        }

        // Classe para zonas de vento
        class WindZone {
            constructor(x, y, size) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.pulsePhase = Math.random() * Math.PI * 2;
            }

            update() {
                this.pulsePhase += 0.1;
            }

            draw() {
                const pulse = 0.8 + Math.sin(this.pulsePhase) * 0.2;
                ctx.save();
                ctx.globalAlpha = 0.3 * pulse;
                ctx.fillStyle = '#44ff44';
                ctx.beginPath();
                ctx.arc(this.x - gameState.camera.x, this.y - gameState.camera.y, this.size * pulse, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();

                ctx.strokeStyle = '#66ff66';
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.5;
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2 + this.pulsePhase;
                    const x1 = this.x - gameState.camera.x + Math.cos(angle) * this.size * 0.5;
                    const y1 = this.y - gameState.camera.y + Math.sin(angle) * this.size * 0.5;
                    const x2 = this.x - gameState.camera.x + Math.cos(angle) * this.size * 0.8;
                    const y2 = this.y - gameState.camera.y + Math.sin(angle) * this.size * 0.8;
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                }
                ctx.globalAlpha = 1;
            }

            isPlayerInside(player) {
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                return Math.sqrt(dx * dx + dy * dy) < this.size;
            }
        }

        // Classe para constru√ß√µes
        class Building {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.destroyed = false;
                this.health = type === 'house' ? 50 : type === 'skyscraper' ? 150 : 100;
                this.maxHealth = this.health;
                this.width = type === 'house' ? 30 : type === 'skyscraper' ? 20 : 40;
                this.height = type === 'house' ? 25 : type === 'skyscraper' ? 60 : 35;
                this.color = type === 'house' ? '#8B4513' : type === 'skyscraper' ? '#696969' : '#FF4500';
            }

            takeDamage(damage) {
                if (!this.destroyed) {
                    this.health -= damage;
                    if (this.health <= 0) {
                        this.destroyed = true;
                        const points = this.type === 'house' ? 10 : this.type === 'skyscraper' ? 50 : 25;
                        gameState.score += points;
                        return points;
                    }
                }
                return 0;
            }

            draw() {
                if (this.destroyed) return;
                const screenX = this.x - gameState.camera.x;
                const screenY = this.y - gameState.camera.y;
                const shake = this.health < this.maxHealth * 0.5 ? (Math.random() - 0.5) * 2 : 0;

                ctx.fillStyle = this.color;
                if (this.type === 'house') {
                    ctx.fillRect(screenX + shake, screenY + shake, this.width, this.height);
                    ctx.fillStyle = '#A0522D';
                    ctx.beginPath();
                    ctx.moveTo(screenX + shake, screenY + shake);
                    ctx.lineTo(screenX + this.width/2 + shake, screenY - 10 + shake);
                    ctx.lineTo(screenX + this.width + shake, screenY + shake);
                    ctx.closePath();
                    ctx.fill();
                } else if (this.type === 'skyscraper') {
                    ctx.fillRect(screenX + shake, screenY + shake, this.width, this.height);
                    ctx.fillStyle = '#FFFF00';
                    for (let i = 0; i < 3; i++) {
                        for (let j = 0; j < 8; j++) {
                            if (Math.random() > 0.3) {
                                ctx.fillRect(screenX + 3 + i * 5 + shake, screenY + 5 + j * 6 + shake, 3, 3);
                            }
                        }
                    }
                } else {
                    ctx.fillRect(screenX + shake, screenY + shake, this.width, this.height);
                    ctx.fillStyle = '#8B0000';
                    ctx.fillRect(screenX + this.width - 8 + shake, screenY - 15 + shake, 6, 20);
                }

                if (this.health < this.maxHealth) {
                    const barWidth = this.width;
                    const barHeight = 3;
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(screenX, screenY - 8, barWidth, barHeight);
                    ctx.fillStyle = '#00ff00';
                    ctx.fillRect(screenX, screenY - 8, barWidth * (this.health / this.maxHealth), barHeight);
                }
            }

            isPlayerColliding(player) {
                if (this.destroyed) return false;
                return player.x < this.x + this.width &&
                       player.x + player.size > this.x &&
                       player.y < this.y + this.height &&
                       player.y + player.size > this.y;
            }
        }

        // Classe para furac√µes pequenos
        class SmallHurricane {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.size = 8 + Math.random() * 5;
                this.maxSize = 25;
                this.rotation = 0;
                this.particles = [];
                this.growthRate = 0.07; // crescimento acelerado
                this.canBeAbsorbed = true;

                for (let i = 0; i < 8; i++) {
                    this.particles.push(new Particle(x, y, Math.random() * this.size, 
                                                   0.08 + Math.random() * 0.05, '#ffaa44'));
                }
            }

            update() {
                gameState.windZones.forEach(zone => {
                    const dx = this.x - zone.x;
                    const dy = this.y - zone.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < zone.size) {
                        this.size = Math.min(this.maxSize, this.size + this.growthRate);
                        if (this.size > 15) {
                            this.canBeAbsorbed = false;
                        }
                    }
                });

                this.vx += (Math.random() - 0.5) * 0.2;
                this.vy += (Math.random() - 0.5) * 0.2;

                this.vx *= 0.98;
                this.vy *= 0.98;

                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                if (speed > 1) {
                    this.vx = (this.vx / speed) * 1;
                    this.vy = (this.vy / speed) * 1;
                }

                this.x += this.vx;
                this.y += this.vy;

                this.x = Math.max(this.size, Math.min(gameState.mapSize - this.size, this.x));
                this.y = Math.max(this.size, Math.min(gameState.mapSize - this.size, this.y));

                this.rotation += 0.15;

                this.particles.forEach(particle => {
                    particle.update(this.x, this.y, this.rotation);
                    if (particle.life <= 0) {
                        particle.life = 1;
                        particle.distance = Math.random() * this.size;
                        particle.angle = Math.random() * Math.PI * 2;
                    }
                });

                if (this.particles.length < this.size && Math.random() < 0.1) {
                    this.particles.push(new Particle(this.x, this.y, Math.random() * this.size, 
                                                   0.08 + Math.random() * 0.05, '#ffaa44'));
                }
            }

            draw() {
                ctx.fillStyle = this.canBeAbsorbed ? '#ffaa00' : '#ff6600';
                ctx.beginPath();
                ctx.arc(this.x - gameState.camera.x, this.y - gameState.camera.y, this.size * 0.3, 0, Math.PI * 2);
                ctx.fill();

                this.particles.forEach(particle => {
                    ctx.save();
                    ctx.globalAlpha = particle.life;
                    ctx.fillStyle = particle.color;
                    ctx.beginPath();
                    ctx.arc(particle.x - gameState.camera.x, particle.y - gameState.camera.y, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                });
            }

            canPlayerAbsorb(player) {
                if (!this.canBeAbsorbed) return false;
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < (player.size + this.size) * 0.8;
            }
        }

        // Classe para habitantes (pontinhos que fogem)
        class Inhabitant {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.size = 2;
                this.speed = 2 + Math.random() * 2;
                this.panicRadius = 80;
                this.life = 5;
                this.color = '#000000';
            }

            update() {
                let nearestThreat = null;
                let nearestDistance = Infinity;
                const playerDist = Math.sqrt((this.x - gameState.player.x) ** 2 + (this.y - gameState.player.y) ** 2);
                if (playerDist < this.panicRadius && playerDist < nearestDistance) {
                    nearestThreat = gameState.player;
                    nearestDistance = playerDist;
                }
                gameState.enemies.forEach(enemy => {
                    const dist = Math.sqrt((this.x - enemy.x) ** 2 + (this.y - enemy.y) ** 2);
                    if (dist < this.panicRadius && dist < nearestDistance) {
                        nearestThreat = enemy;
                        nearestDistance = dist;
                    }
                });
                gameState.smallHurricanes.forEach(hurricane => {
                    const dist = Math.sqrt((this.x - hurricane.x) ** 2 + (this.y - hurricane.y) ** 2);
                    if (dist < this.panicRadius && dist < nearestDistance) {
                        nearestThreat = hurricane;
                        nearestDistance = dist;
                    }
                });

                if (nearestThreat) {
                    const dx = this.x - nearestThreat.x;
                    const dy = this.y - nearestThreat.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance > 0) {
                        this.vx += (dx / distance) * this.speed * 0.5;
                        this.vy += (dy / distance) * this.speed * 0.5;
                    }
                }

                this.vx *= 0.8;
                this.vy *= 0.8;

                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                if (speed > this.speed) {
                    this.vx = (this.vx / speed) * this.speed;
                    this.vy = (this.vy / speed) * this.speed;
                }

                this.x += this.vx;
                this.y += this.vy;

                this.x = Math.max(0, Math.min(gameState.mapSize, this.x));
                this.y = Math.max(0, Math.min(gameState.mapSize, this.y));

                this.life -= 1/60;
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x - gameState.camera.x, this.y - gameState.camera.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }

            isDead() {
                return this.life <= 0;
            }
        }

        // Inicializar jogo
        function initGame() {
            gameState.player.x = 1000;
            gameState.player.y = 1000;
            gameState.player.vx = 0;
            gameState.player.vy = 0;
            gameState.player.energy = 100;
            gameState.player.particles = [];
            gameState.enemies = [];
            gameState.smallHurricanes = [];
            gameState.windZones = [];
            gameState.buildings = [];
            gameState.inhabitants = [];
            gameState.gameTime = 0;
            gameState.gameRunning = true;
            gameState.score = 0;

            for (let i = 0; i < 15; i++) {
                gameState.player.particles.push(new Particle(
                    gameState.player.x, gameState.player.y, 
                    Math.random() * gameState.player.size, 
                    0.05 + Math.random() * 0.1, '#4488ff'
                ));
            }

            const cityPositions = [
                { x: 400, y: 400 },
                { x: 1200, y: 300 },
                { x: 800, y: 1400 },
                { x: 1600, y: 800 }
            ];

            cityPositions.forEach(city => {
                for (let i = 0; i < 8; i++) {
                    const x = city.x + (Math.random() - 0.5) * 150;
                    const y = city.y + (Math.random() - 0.5) * 150;
                    gameState.buildings.push(new Building(x, y, 'skyscraper'));
                }

                for (let i = 0; i < 15; i++) {
                    const angle = (i / 15) * Math.PI * 2;
                    const distance = 200 + Math.random() * 100;
                    const x = city.x + Math.cos(angle) * distance;
                    const y = city.y + Math.sin(angle) * distance;
                    const type = Math.random() < 0.8 ? 'house' : 'factory';
                    gameState.buildings.push(new Building(x, y, type));
                }
            });

            for (let i = 0; i < 30; i++) {
                let x, y;
                let validPosition = false;
                let attempts = 0;
                while (!validPosition && attempts < 50) {
                    x = Math.random() * gameState.mapSize;
                    y = Math.random() * gameState.mapSize;
                    validPosition = true;
                    for (let city of cityPositions) {
                        if (Math.sqrt((x - city.x) ** 2 + (y - city.y) ** 2) < 300) {
                            validPosition = false;
                            break;
                        }
                    }
                    attempts++;
                }
                if (validPosition) {
                    gameState.buildings.push(new Building(x, y, 'house'));
                }
            }

            for (let i = 0; i < 4; i++) {
                let x, y;
                do {
                    x = Math.random() * gameState.mapSize;
                    y = Math.random() * gameState.mapSize;
                } while (Math.sqrt((x - gameState.player.x) ** 2 + (y - gameState.player.y) ** 2) < 300);
                gameState.enemies.push(new Enemy(x, y));
            }

            for (let i = 0; i < 12; i++) {
                gameState.windZones.push(new WindZone(
                    Math.random() * gameState.mapSize,
                    Math.random() * gameState.mapSize,
                    50 + Math.random() * 50
                ));
            }

            // Aumenta o spawn inicial de furac√µes pequenos
            for (let i = 0; i < 15; i++) {
                gameState.smallHurricanes.push(new SmallHurricane(
                    Math.random() * gameState.mapSize,
                    Math.random() * gameState.mapSize
                ));
            }

            document.getElementById('game-over').style.display = 'none';
        }

        // Controles
        document.addEventListener('keydown', (e) => {
            gameState.keys[e.key.toLowerCase()] = true;
            if (e.key === ' ') {
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            gameState.keys[e.key.toLowerCase()] = false;
        });

        let touchStartX = 0;
        let touchStartY = 0;
        let touchDirection = { x: 0, y: 0 };

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            touchDirection.x = (touch.clientX - touchStartX) / 100;
            touchDirection.y = (touch.clientY - touchStartY) / 100;
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            touchDirection.x = 0;
            touchDirection.y = 0;
        });

        // Fun√ß√£o de canibalismo dos furac√µes
        function hurricaneCanibalism() {
            // SmallHurricanes podem ser absorvidos por inimigos
            gameState.enemies.forEach(enemy => {
                gameState.smallHurricanes.forEach((small, idx) => {
                    const dx = enemy.x - small.x;
                    const dy = enemy.y - small.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (enemy.size > small.size * 1.2 && dist < (enemy.size + small.size) * 0.7) {
                        enemy.size = Math.min(enemy.maxSize, enemy.size + small.size / 10);
                        gameState.smallHurricanes.splice(idx, 1);
                    }
                });
            });
            // Inimigos absorvem outros inimigos menores
            for (let i = 0; i < gameState.enemies.length; i++) {
                for (let j = 0; j < gameState.enemies.length; j++) {
                    if (i !== j) {
                        let e1 = gameState.enemies[i];
                        let e2 = gameState.enemies[j];
                        const dx = e1.x - e2.x;
                        const dy = e1.y - e2.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (e1.size > e2.size * 1.2 && dist < (e1.size + e2.size) * 0.7) {
                            e1.size = Math.min(e1.maxSize, e1.size + e2.size / 12);
                            gameState.enemies.splice(j, 1);
                            if (j < i) i--;
                            break;
                        }
                    }
                }
            }
        }

        // Fun√ß√£o de atualiza√ß√£o
        function update() {
            if (!gameState.gameRunning) return;

            const player = gameState.player;
            let inputX = 0;
            let inputY = 0;
            if (gameState.keys['w'] || gameState.keys['arrowup']) inputY -= 1;
            if (gameState.keys['s'] || gameState.keys['arrowdown']) inputY += 1;
            if (gameState.keys['a'] || gameState.keys['arrowleft']) inputX -= 1;
            if (gameState.keys['d'] || gameState.keys['arrowright']) inputX += 1;
            inputX += touchDirection.x;
            inputY += touchDirection.y;

            const force = 0.5;
            player.vx += inputX * force;
            player.vy += inputY * force;

            let isDashing = false;
            if (gameState.keys[' '] && player.energy > 20) {
                const dashForce = 5;
                player.vx += inputX * dashForce;
                player.vy += inputY * dashForce;
                player.energy -= 2;
                isDashing = true;
                gameState.keys[' '] = false;
            }

            player.vx *= 0.95;
            player.vy *= 0.95;

            const maxSpeed = 8;
            const speed = Math.sqrt(player.vx * player.vx + player.vy * player.vy);
            if (speed > maxSpeed) {
                player.vx = (player.vx / speed) * maxSpeed;
                player.vy = (player.vy / speed) * maxSpeed;
            }

            player.x += player.vx;
            player.y += player.vy;

            player.x = Math.max(player.size, Math.min(gameState.mapSize - player.size, player.x));
            player.y = Math.max(player.size, Math.min(gameState.mapSize - player.size, player.y));
            gameState.camera.x = player.x - canvas.width / 2;
            gameState.camera.y = player.y - canvas.height / 2;

            if (speed > 0.1) {
                player.rotation += speed * 0.1;
            }

            player.energy -= 0.08;

            let inWindZone = false;
            gameState.windZones.forEach(zone => {
                if (zone.isPlayerInside(player)) {
                    player.energy += 1.5;
                    inWindZone = true;
                }
                zone.update();
            });

            player.energy = Math.max(0, Math.min(100, player.energy));

            player.particles.forEach(particle => {
                particle.update(player.x, player.y, player.rotation);
                if (particle.life <= 0) {
                    particle.life = 1;
                    particle.distance = Math.random() * player.size;
                    particle.angle = Math.random() * Math.PI * 2;
                }
            });

            // Spawn cont√≠nuo de furac√µes pequenos
            smallHurricaneSpawnTimer += 1/60;
            if (smallHurricaneSpawnTimer > 2) {
                gameState.smallHurricanes.push(new SmallHurricane(
                    Math.random() * gameState.mapSize,
                    Math.random() * gameState.mapSize
                ));
                smallHurricaneSpawnTimer = 0;
            }

            // Spawn cont√≠nuo de casas
            houseSpawnTimer += 1/60;
            if (houseSpawnTimer > 10) {
                let x, y;
                let valid = false;
                let tries = 0;
                while (!valid && tries < 20) {
                    x = Math.random() * gameState.mapSize;
                    y = Math.random() * gameState.mapSize;
                    valid = true;
                    [{x:400,y:400},{x:1200,y:300},{x:800,y:1400},{x:1600,y:800}].forEach(city => {
                        if (Math.sqrt((x-city.x)**2 + (y-city.y)**2) < 250) valid = false;
                    });
                    tries++;
                }
                if (valid) gameState.buildings.push(new Building(x, y, 'house'));
                houseSpawnTimer = 0;
            }

            // Atualizar furac√µes pequenos e absor√ß√£o por tamanho
            gameState.smallHurricanes.forEach((hurricane, index) => {
                hurricane.update();
                if (isDashing && player.size > hurricane.size * 1.2) {
                    const dx = player.x - hurricane.x;
                    const dy = player.y - hurricane.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < (player.size + hurricane.size) * 0.8) {
                        const energyGain = Math.floor(hurricane.size / 2) + 10;
                        const sizeGain = hurricane.size / 10; // crescimento mais r√°pido
                        player.energy += energyGain;
                        player.size = Math.min(player.maxSize, player.size + sizeGain);
                        gameState.score += Math.floor(hurricane.size);
                        gameState.smallHurricanes.splice(index, 1);
                        const particlesToAdd = Math.floor(hurricane.size / 5);
                        for (let i = 0; i < particlesToAdd; i++) {
                            player.particles.push(new Particle(
                                player.x, player.y, 
                                Math.random() * player.size, 
                                0.05 + Math.random() * 0.1, '#4488ff'
                            ));
                        }
                    }
                }
            });

            // Absor√ß√£o de furac√µes inimigos menores
            gameState.enemies.forEach((enemy, index) => {
                enemy.update();
                if (isDashing && enemy.canPlayerAbsorb(player)) {
                    const dx = player.x - enemy.x;
                    const dy = player.y - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < (player.size + enemy.size) * 0.7) {
                        const energyGain = Math.floor(enemy.size / 1.5) + 25;
                        const sizeGain = enemy.size / 6; // crescimento mais r√°pido
                        player.energy += energyGain;
                        player.size = Math.min(player.maxSize, player.size + sizeGain);
                        gameState.score += enemy.size * 2;
                        gameState.enemies.splice(index, 1);
                        const particlesToAdd = Math.floor(enemy.size / 3);
                        for (let i = 0; i < particlesToAdd; i++) {
                            player.particles.push(new Particle(
                                player.x, player.y, 
                                Math.random() * player.size, 
                                0.05 + Math.random() * 0.1, '#4488ff'
                            ));
                        }
                    }
                }
            });

            // Canibalismo autom√°tico entre furac√µes
            hurricaneCanibalism();

            // TODO: restando: atualizar habitantes, pr√©dios e desenhar tudo...

            // Continue update loop...
            // requestAnimationFrame(update);
        }

        // Fun√ß√£o para reiniciar o jogo
        function restartGame() {
            initGame();
            requestAnimationFrame(gameLoop);
        }

        // Fun√ß√£o principal do jogo (update + render)
        function gameLoop() {
            update();
            // render(); // Supondo que o render j√° existe
            requestAnimationFrame(gameLoop);
        }

        // Inicializa√ß√£o
        initGame();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
